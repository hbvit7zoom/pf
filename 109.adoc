```
;;  {:valor 29.0, :tipo "despesa", :comentario "Livro de Clojure",

;;   :moeda "R$", :data "03/12/2016"}
;;  {:valor 45M, :tipo "despesa", :comentario "Jogo no Steam",
;;   :moeda "R$", :data "26/12/2016"})
```

Não  parece  haver  nada  diferente,  certo?  Se   `filter`   avalia
listas tardiamente, o que deveríamos ter visto? Só para provar que
estou falando a verdade, olhe qual é a classe que  `filter`  retorna:

```
(class (filter despesa? transacoes))
;; clojure.lang.LazySeq
```

Então,  é  mesmo  uma  sequência  preguiçosa.  Mas  onde  está  a
diferença? Olhe ela aqui:

```
;; vamos associar a sequência de despesas a um nome
(def despesas (filter despesa? transacoes))
;; #'user/despesas

;; `filter` só é aplicada quando `despesas` é avaliada
despesas
;; ({:valor 33.0, :tipo "despesa", :comentario "Almoço",
;;   :moeda "R$", :data "19/11/2016"}
;;  {:valor 29.0, :tipo "despesa", :comentario "Livro de Clojure"
,
;;   :moeda "R$", :data "03/12/2016"}
;;  {:valor 45M, :tipo "despesa", :comentario "Jogo no Steam",
;;   :moeda "R$", :data "26/12/2016"})
```

Repare  que,  quando  declaramos    `despesas`  ,    (`filter
despesa? transacoes`)  não é avaliada. Acontece apenas quando
queremos ver o valor de  `despesas` .  E,  ainda  assim,  só  acontece
porque  estamos  no  REPL  e,  ao  avaliar    `despesas`  ,  o  REPL
imprime  o  resultado  na  tela,  o  que  faz  com  que  a  sequência  seja
consumida.

Em um outro exemplo, com  map , o mesmo acontece:

```
;; vamos pegar o valor e a moeda de uma transação
```