```
     acumulado
     (saldo (calcular acumulado (first transacoes))
            (rest transacoes)))))

(saldo poucas-transacoes)
;; 45

(saldo muitas-transacoes)
;; 499500

(saldo incontaveis-transacoes)
;; StackOverflowError...
```

Como  pode  ser  visto,  o  resultado  continua  sendo  o  mesmo:
estouro de pilha.  Só que agora  podemos fazer uso  de uma forma
especial de Clojure que faz a _tail recursion elimination_:  `recur` :

```
;; nova versão de saldo, desta vez com recur
(defn saldo
  ([transacoes] (saldo 0 transacoes))
  ([acumulado transacoes]
   (if (empty? transacoes)
     acumulado
;;    vvvvv aqui utilizamos recur em vez de saldo
     (recur (calcular acumulado (first transacoes))
            (rest transacoes)))))

(saldo muitas-transacoes)
;; 499500

(saldo incontaveis-transacoes)
;; 4999950000
```

`recur`    é  usada  para  indicar  que  um  loop  recursivo  vai
começar  e  o  compilador  pode  realizar  suas  otimizações.  Perceba
que  a  última  chamada  em   saldo   é   `recur` ,  e  não  uma  nova
chamada  a    `saldo`  ,  como  nos  exemplos  anteriores.    `recur` 
primeiro  avalia  os  argumentos  ( (`calcular  acumulado`  (`first
transacoes`))   e   (`rest  transacoes`) ).  Em  paralelo,  refaz  as
referências  que  são  argumentos  no  loop  (  `acumulado`    e